// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

// Looking for ways to speed up your queries, or scale easily with your serverless or edge functions?
// Try Prisma Accelerate: https://pris.ly/cli/accelerate-init

generator client {
  provider = "prisma-client-js"
  output   = "../src/generated/prisma"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id              String           @id @default(uuid()) // Changed to UUID
  email           String?          @unique
  phone           String?          @unique
  name            String
  password        String
  role            Role             @default(USER)
  createdAt       DateTime         @default(now())
  updatedAt       DateTime         @updatedAt
  isActive        Boolean          @default(true)
  // A user can create many brands (if their role is 'BRAND')
  brands          Brand[]          @relation("UserBrands") // Add this to complete the relation
  products        Product[]
  sales           Sale[]           @relation("MerchantSales")
  // NEW: one-to-one merchant profile
  merchantProfile MerchantProfile?
  addresses       UserAddress[] // NEW

  Order Order[]

  CommissionSetting CommissionSetting[]

  Payout Payout[] @relation("MerchantPayouts")
}

// model UserAddress {
//   id        String   @id @default(cuid())
//   userId    String
//   user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)

//   label     String?        // "Home", "Office", etc.
//   firstName  String
//   lastName  String
//   phone     String
//   address  String
//   address2  String?
//   city      String
//   postcode  String
//   country   String @default("Bangladesh")
//   isDefault Boolean @default(false)

//   createdAt DateTime @default(now())
//   updatedAt DateTime @updatedAt

//   @@index([userId, isDefault])
//   Order Order[]
// }

model UserAddress {
  id     String @id @default(cuid())
  userId String
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)

  firstName String
  lastName  String
  phone     String
  email     String? // optional if you prefer to use User.email
  address   String // full free-form address line
  isDefault Boolean @default(false)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  Order     Order[]

  @@index([userId, isDefault])
}

model MerchantProfile {
  id     String @id @default(uuid())
  userId String @unique
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)

  // Personal Information (keep email/phone in User; allow contact overrides if needed)
  fullName        String   @db.VarChar(120)
  dateOfBirth     DateTime
  contactEmail    String   @db.VarChar(190)
  contactPhone    String   @db.VarChar(32)
  nidOrPassportNo String   @db.VarChar(64)

  presentAddress   String @db.VarChar(255)
  permanentAddress String @db.VarChar(255)

  portfolioUrl String? @db.VarChar(255)
  websiteUrl   String? @db.VarChar(255)

  // Bank (single account from your form; split into its own model later if you need multi-account)
  bankName      String @db.VarChar(80) // e.g., "DBBL"
  bankBranch    String @db.VarChar(80) // e.g., "Dhaka"
  accountName   String @db.VarChar(120)
  accountNumber String @db.VarChar(64)
  routingNumber String @db.VarChar(64)

  // Additional
  message     String?  @db.Text
  tiar        Int      @default(10)
  leftTiar    Int      @default(0)
  brandOption Boolean  @default(false)
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  @@index([bankName, bankBranch])
}

model Brand {
  id              String        @id @default(uuid()) // Changed to UUID
  name            String
  isActive        Boolean       @default(false) // Default is false for new brands
  createdAt       DateTime      @default(now())
  updatedAt       DateTime      @updatedAt
  brandCategory   BrandCategory @relation(fields: [brandCategoryId], references: [id])
  brandCategoryId String
  user            User          @relation("UserBrands", fields: [userId], references: [id])
  userId          String
  Product         Product[]

  Sales Sale[] @relation("BrandSales")

  // Default commission settings for this brand
  defaultBrandPct    Float @default(10.0) // brand share
  defaultMerchantPct Float @default(10.0) // merchant share

  // Personal Information (keep email/phone in User; allow contact overrides if needed)

  dateOfBirth     DateTime
  contactEmail    String   @db.VarChar(190)
  contactPhone    String   @db.VarChar(32)
  nidOrPassportNo String   @db.VarChar(64)

  presentAddress   String @db.VarChar(255)
  permanentAddress String @db.VarChar(255)

  portfolioUrl String? @db.VarChar(255)
  websiteUrl   String? @db.VarChar(255)

  // Bank (single account from your form; split into its own model later if you need multi-account)
  bankName      String @db.VarChar(80) // e.g., "DBBL"
  bankBranch    String @db.VarChar(80) // e.g., "Dhaka"
  accountName   String @db.VarChar(120)
  accountNumber String @db.VarChar(64)
  routingNumber String @db.VarChar(64)

  // Additional
  message String? @db.Text

  industryType  String
  socialProfile String

  CommissionSetting CommissionSetting[]

  Payout Payout[] @relation("BrandPayouts")
}

model BrandCategory {
  id        String   @id @default(uuid()) // Changed to UUID
  name      String
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  Brand     Brand[] // One-to-many relation with Brand
}

model Product {
  id          String   @id @default(uuid())
  productId   String   @unique
  title       String
  description String?
  price       Float
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  isActive    Boolean  @default(false)
  // Brand handling

  brandName String?
  brandId   String?
  Brand     Brand?  @relation(fields: [brandId], references: [id])

  // Relations
  features Feature[]
  tags     Tag[]
  mockupId String
  Mockup   Mockup           @relation(fields: [mockupId], references: [id])
  variants ProductVariant[] // <-- each product has multiple variants

  userId String
  User   User   @relation(fields: [userId], references: [id])

  visibility Boolean @default(true)

  // Design File

  backDesign  String?
  frontDesign String

  // New: commission % settings
  brandCommissionPct    Float? // % goes to brand (if Brand attached)
  merchantCommissionPct Float? // % goes to merchant on each sale

  sales Sale[] // track product sales

  CommissionSetting CommissionSetting[]
}

model Sale {
  id          String    @id @default(uuid())
  orderItemId String    @unique
  orderItem   OrderItem @relation(fields: [orderItemId], references: [id], onDelete: Cascade)
  productId   String
  product     Product   @relation(fields: [productId], references: [id], onDelete: Cascade)

  merchantId String
  merchant   User   @relation("MerchantSales", fields: [merchantId], references: [id])

  brandId String? // null if product had no brand
  brand   Brand?  @relation("BrandSales", fields: [brandId], references: [id])

  quantity Int   @default(1)
  total    Float // total sale amount

  // Earnings
  brandEarning    Float    @default(0)
  merchantEarning Float    @default(0)
  platformEarning Float    @default(0)
  createdAt       DateTime @default(now())

  @@index([productId, createdAt]) // speeds up time-window queries
  SaleItem SaleItem[]
}

model SaleItem {
  id          String  @id @default(uuid())
  saleId      String
  productId   String
  quantity    Int
  unitPrice   Decimal
  total       Decimal

  // add this:
  orderItemId String  @unique

  Sale        Sale    @relation(fields: [saleId], references: [id])
}

model ProductVariant {
  id        String  @id @default(uuid())
  productId String
  product   Product @relation(fields: [productId], references: [id], onDelete: Cascade)

  color   String  @db.VarChar(24) // e.g. "black", "green"
  fitType FitType // e.g. MEN, WOMEN, YOUTH

  frontImg String // required: front image
  backImg  String? // optional: back image

  // images ProductImage[] // <-- store multiple variant-specific images

  @@unique([productId, color, fitType]) // <- change this
}

model Feature {
  id        String @id @default(uuid())
  productId String
  content   String

  product Product @relation(fields: [productId], references: [id], onDelete: Cascade)
}

model Tag {
  id        String @id @default(uuid())
  productId String
  value     String

  product Product @relation(fields: [productId], references: [id], onDelete: Cascade)
}

model Mockup {
  id        String          @id @default(uuid())
  name      String
  variants  MockupVariant[] // one row per (color, fitType)
  createdAt DateTime        @default(now())
  updatedAt DateTime        @updatedAt
  Product   Product[]
}

model MockupVariant {
  id       String @id @default(uuid())
  mockupId String
  mockup   Mockup @relation(fields: [mockupId], references: [id], onDelete: Cascade)

  color   String  @db.VarChar(24) // e.g. "black", "green"
  fitType FitType // e.g. MEN, WOMEN, YOUTH

  frontImg String // required: front image
  backImg  String // optional: back image

  @@unique([mockupId, color, fitType]) // one row per (mockup, color, fitType)
}

model Order {
  id String @id @default(cuid())

  // required: no guest orders
  userId String
  user   User   @relation(fields: [userId], references: [id])

  // required: always point to a saved address
  addressId String
  address   UserAddress @relation(fields: [addressId], references: [id])
  // (default referential action prevents deleting an address thatâ€™s used)

  // money
  currency    String  @default("BDT")
  subtotal    Decimal @db.Decimal(12, 2)
  discount    Decimal @default(0) @db.Decimal(12, 2)
  tax         Decimal @default(0) @db.Decimal(12, 2)
  shippingFee Decimal @default(0) @db.Decimal(12, 2)
  grandTotal  Decimal @db.Decimal(12, 2)

  // coupon
  couponCode String?
  couponRate Decimal? @db.Decimal(5, 4)

  // payment / gateway
  status String @default("PENDING") // PENDING | PAID | FAILED | CANCELLED
  tranId String @unique

  // relations
  items   OrderItem[]
  payment Payment?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  settledAt DateTime?

  @@index([userId, createdAt])
  @@index([addressId])
}

model OrderItem {
  id      String @id @default(cuid())
  orderId String
  order   Order  @relation(fields: [orderId], references: [id], onDelete: Cascade)

  productId    String?
  productTitle String
  unitPrice    Decimal @db.Decimal(12, 2)
  quantity     Int     @default(1)

  color   String?
  fitType FitType?
  size    String?

  Sale Sale[]
}

model Payment {
  id         String   @id @default(cuid())
  orderId    String   @unique
  order      Order    @relation(fields: [orderId], references: [id], onDelete: Cascade)
  valId      String? // from SSLCOMMERZ validation / redirect/IPN
  bankTranId String? // bank_tran_id
  cardType   String?
  rawPayload Json? // store last payload (success/ipn)
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt
}

model CommissionSetting {
  id String @id @default(uuid())

  // Optional foreign keys to associate commissions with specific Brand or Merchant
  brandId String?
  brand   Brand?  @relation(fields: [brandId], references: [id], onDelete: Cascade)

  merchantId String?
  merchant   User?   @relation(fields: [merchantId], references: [id], onDelete: Cascade)

  // Commission percentages
  brandCommissionPct    Float @default(10.0) // default brand share in %
  merchantCommissionPct Float @default(10.0) // default merchant share in %

  // Apply globally or to specific products if needed
  productId String?
  product   Product? @relation(fields: [productId], references: [id], onDelete: Cascade)

  // For versioning or tracking
  effectiveFrom DateTime  @default(now())
  effectiveTo   DateTime?
  isActive      Boolean   @default(true)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([brandId, merchantId, productId])
}

enum PayoutActor {
  BRAND
  MERCHANT
}

model Payout {
  id         String      @id @default(uuid())
  actor      PayoutActor
  brandId    String?
  merchantId String?

  amount    Decimal  @db.Decimal(12, 2)
  note      String?
  createdAt DateTime @default(now())

  // named relations + SetNull keeps payout records if brand/user gets removed
  brand    Brand? @relation("BrandPayouts", fields: [brandId], references: [id], onDelete: SetNull)
  merchant User?  @relation("MerchantPayouts", fields: [merchantId], references: [id], onDelete: SetNull)

  @@index([actor, brandId, merchantId, createdAt])
}

enum FitType {
  MEN
  WOMEN
  YOUTH
}

enum Role {
  USER
  ADMIN
  BRAND // Added the BRAND role
  MERCH
}

enum Visibility {
  SEARCHABLE
  NON_SEARCHABLE
}

enum ImageType {
  FRONT
  BACK
}
